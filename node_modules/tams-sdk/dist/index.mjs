var __defProp = Object.defineProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};

// __generated__/apis/tams.ts
var tams_exports = {};
__export(tams_exports, {
  Api: () => Api,
  ContentType: () => ContentType,
  HttpClient: () => HttpClient,
  ImageToInpaintInputInpaintFillT: () => ImageToInpaintInputInpaintFillT,
  ImageToInpaintInputResizeModeT: () => ImageToInpaintInputResizeModeT,
  ProjectModelTypeT: () => ProjectModelTypeT,
  ProtobufNullValue: () => ProtobufNullValue,
  TamsApiJobStatusT: () => TamsApiJobStatusT,
  TamsApiStageTypeT: () => TamsApiStageTypeT
});
var ImageToInpaintInputInpaintFillT = /* @__PURE__ */ ((ImageToInpaintInputInpaintFillT2) => {
  ImageToInpaintInputInpaintFillT2["DEFAULT"] = "DEFAULT";
  ImageToInpaintInputInpaintFillT2["FILL"] = "FILL";
  ImageToInpaintInputInpaintFillT2["ORIGINAL"] = "ORIGINAL";
  ImageToInpaintInputInpaintFillT2["LATENT_NOISE"] = "LATENT_NOISE";
  ImageToInpaintInputInpaintFillT2["LATENT_NOTHING"] = "LATENT_NOTHING";
  return ImageToInpaintInputInpaintFillT2;
})(ImageToInpaintInputInpaintFillT || {});
var ImageToInpaintInputResizeModeT = /* @__PURE__ */ ((ImageToInpaintInputResizeModeT2) => {
  ImageToInpaintInputResizeModeT2["DEFAULT"] = "DEFAULT";
  ImageToInpaintInputResizeModeT2["JUST_RESIZE"] = "JUST_RESIZE";
  ImageToInpaintInputResizeModeT2["CROP_AND_RESIZE"] = "CROP_AND_RESIZE";
  ImageToInpaintInputResizeModeT2["RESIZE_AND_FILL"] = "RESIZE_AND_FILL";
  ImageToInpaintInputResizeModeT2["JUST_RESIZE_LATENT_UPSCALE"] = "JUST_RESIZE_LATENT_UPSCALE";
  return ImageToInpaintInputResizeModeT2;
})(ImageToInpaintInputResizeModeT || {});
var ProjectModelTypeT = /* @__PURE__ */ ((ProjectModelTypeT2) => {
  ProjectModelTypeT2["DEFAULT"] = "DEFAULT";
  ProjectModelTypeT2["CHECKPOINT"] = "CHECKPOINT";
  ProjectModelTypeT2["TEXTUAL_INVERSION"] = "TEXTUAL_INVERSION";
  ProjectModelTypeT2["HYPERNETWORK"] = "HYPERNETWORK";
  ProjectModelTypeT2["AESTHETIC_GRADIENT"] = "AESTHETIC_GRADIENT";
  ProjectModelTypeT2["LORA"] = "LORA";
  ProjectModelTypeT2["LOCON"] = "LOCON";
  ProjectModelTypeT2["CONTROLNET"] = "CONTROLNET";
  ProjectModelTypeT2["POSES"] = "POSES";
  ProjectModelTypeT2["WILDCARDS"] = "WILDCARDS";
  ProjectModelTypeT2["OTHER"] = "OTHER";
  ProjectModelTypeT2["LYCORIS"] = "LYCORIS";
  return ProjectModelTypeT2;
})(ProjectModelTypeT || {});
var ProtobufNullValue = /* @__PURE__ */ ((ProtobufNullValue2) => {
  ProtobufNullValue2["NULL_VALUE"] = "NULL_VALUE";
  return ProtobufNullValue2;
})(ProtobufNullValue || {});
var TamsApiJobStatusT = /* @__PURE__ */ ((TamsApiJobStatusT2) => {
  TamsApiJobStatusT2["DEFAULT"] = "DEFAULT";
  TamsApiJobStatusT2["CREATED"] = "CREATED";
  TamsApiJobStatusT2["PENDING"] = "PENDING";
  TamsApiJobStatusT2["RUNNING"] = "RUNNING";
  TamsApiJobStatusT2["CANCELED"] = "CANCELED";
  TamsApiJobStatusT2["SUCCESS"] = "SUCCESS";
  TamsApiJobStatusT2["FAILED"] = "FAILED";
  TamsApiJobStatusT2["WAITING"] = "WAITING";
  return TamsApiJobStatusT2;
})(TamsApiJobStatusT || {});
var TamsApiStageTypeT = /* @__PURE__ */ ((TamsApiStageTypeT2) => {
  TamsApiStageTypeT2["DEFAULT"] = "DEFAULT";
  TamsApiStageTypeT2["INPUT_INITIALIZE"] = "INPUT_INITIALIZE";
  TamsApiStageTypeT2["DIFFUSION"] = "DIFFUSION";
  TamsApiStageTypeT2["IMAGE_TO_UPSCALER"] = "IMAGE_TO_UPSCALER";
  TamsApiStageTypeT2["IMAGE_TO_ADETAILER"] = "IMAGE_TO_ADETAILER";
  TamsApiStageTypeT2["IMAGE_TO_INPAINT"] = "IMAGE_TO_INPAINT";
  return TamsApiStageTypeT2;
})(TamsApiStageTypeT || {});
var ContentType = /* @__PURE__ */ ((ContentType2) => {
  ContentType2["Json"] = "application/json";
  ContentType2["FormData"] = "multipart/form-data";
  ContentType2["UrlEncoded"] = "application/x-www-form-urlencoded";
  ContentType2["Text"] = "text/plain";
  return ContentType2;
})(ContentType || {});
var HttpClient = class {
  baseUrl = "https://tams.tensor.art";
  securityData = null;
  securityWorker;
  abortControllers = /* @__PURE__ */ new Map();
  customFetch = (...fetchParams) => fetch(...fetchParams);
  baseApiParams = {
    credentials: "same-origin",
    headers: {},
    redirect: "follow",
    referrerPolicy: "no-referrer"
  };
  constructor(apiConfig = {}) {
    Object.assign(this, apiConfig);
  }
  setSecurityData = (data) => {
    this.securityData = data;
  };
  encodeQueryParam(key, value) {
    const encodedKey = encodeURIComponent(key);
    return `${encodedKey}=${encodeURIComponent(typeof value === "number" ? value : `${value}`)}`;
  }
  addQueryParam(query, key) {
    return this.encodeQueryParam(key, query[key]);
  }
  addArrayQueryParam(query, key) {
    const value = query[key];
    return value.map((v) => this.encodeQueryParam(key, v)).join("&");
  }
  toQueryString(rawQuery) {
    const query = rawQuery || {};
    const keys = Object.keys(query).filter((key) => "undefined" !== typeof query[key]);
    return keys.map((key) => Array.isArray(query[key]) ? this.addArrayQueryParam(query, key) : this.addQueryParam(query, key)).join("&");
  }
  addQueryParams(rawQuery) {
    const queryString = this.toQueryString(rawQuery);
    return queryString ? `?${queryString}` : "";
  }
  contentFormatters = {
    ["application/json" /* Json */]: (input) => input !== null && (typeof input === "object" || typeof input === "string") ? JSON.stringify(input) : input,
    ["text/plain" /* Text */]: (input) => input !== null && typeof input !== "string" ? JSON.stringify(input) : input,
    ["multipart/form-data" /* FormData */]: (input) => Object.keys(input || {}).reduce((formData, key) => {
      const property = input[key];
      formData.append(
        key,
        property instanceof Blob ? property : typeof property === "object" && property !== null ? JSON.stringify(property) : `${property}`
      );
      return formData;
    }, new FormData()),
    ["application/x-www-form-urlencoded" /* UrlEncoded */]: (input) => this.toQueryString(input)
  };
  mergeRequestParams(params1, params2) {
    return {
      ...this.baseApiParams,
      ...params1,
      ...params2 || {},
      headers: {
        ...this.baseApiParams.headers || {},
        ...params1.headers || {},
        ...params2 && params2.headers || {}
      }
    };
  }
  createAbortSignal = (cancelToken) => {
    if (this.abortControllers.has(cancelToken)) {
      const abortController2 = this.abortControllers.get(cancelToken);
      if (abortController2) {
        return abortController2.signal;
      }
      return void 0;
    }
    const abortController = new AbortController();
    this.abortControllers.set(cancelToken, abortController);
    return abortController.signal;
  };
  abortRequest = (cancelToken) => {
    const abortController = this.abortControllers.get(cancelToken);
    if (abortController) {
      abortController.abort();
      this.abortControllers.delete(cancelToken);
    }
  };
  request = async ({
    body,
    secure,
    path,
    type,
    query,
    format,
    baseUrl,
    cancelToken,
    ...params
  }) => {
    const secureParams = (typeof secure === "boolean" ? secure : this.baseApiParams.secure) && this.securityWorker && await this.securityWorker(this.securityData) || {};
    const requestParams = this.mergeRequestParams(params, secureParams);
    const queryString = query && this.toQueryString(query);
    const payloadFormatter = this.contentFormatters[type || "application/json" /* Json */];
    const responseFormat = format || requestParams.format;
    return this.customFetch(`${baseUrl || this.baseUrl || ""}${path}${queryString ? `?${queryString}` : ""}`, {
      ...requestParams,
      headers: {
        ...requestParams.headers || {},
        ...type && type !== "multipart/form-data" /* FormData */ ? { "Content-Type": type } : {}
      },
      signal: cancelToken ? this.createAbortSignal(cancelToken) : requestParams.signal,
      body: typeof body === "undefined" || body === null ? null : payloadFormatter(body)
    }).then(async (response) => {
      const r = {};
      r.headers = response.headers;
      r.ok = response.ok;
      const data = !responseFormat ? r : await response[responseFormat]().then((data2) => {
        if (r.ok) {
          r.data = data2;
        } else {
          r.error = data2;
        }
        return r;
      }).catch((e) => {
        r.error = e;
        return r;
      });
      if (cancelToken) {
        this.abortControllers.delete(cancelToken);
      }
      if (r.error) {
        let message = "Unknown Error";
        if (r.error.message) {
          message = r.error.message;
        }
        const err = new Error(message);
        err.response = r;
        throw err;
      }
      return data;
    });
  };
};
var Api = class extends HttpClient {
  v1 = {
    /**
     * @description create diffusion job
     *
     * @tags jobs
     * @name TamsApiV1ServiceCreateJob
     * @summary v1/jobs
     * @request POST:/v1/jobs
     */
    tamsApiV1ServiceCreateJob: (body, params = {}) => this.request({
      path: `/v1/jobs`,
      method: "POST",
      body,
      type: "application/json" /* Json */,
      format: "json",
      ...params
    }),
    /**
     * @description get job
     *
     * @tags jobs
     * @name TamsApiV1ServiceGetJob
     * @summary v1/jobs
     * @request GET:/v1/jobs/{jobId}
     */
    tamsApiV1ServiceGetJob: (jobId, params = {}) => this.request({
      path: `/v1/jobs/${jobId}`,
      method: "GET",
      format: "json",
      ...params
    }),
    /**
     * @description cancel job
     *
     * @tags jobs
     * @name TamsApiV1ServiceCancelJob
     * @summary v1/jobs
     * @request DELETE:/v1/jobs/{jobId}
     */
    tamsApiV1ServiceCancelJob: (jobId, params = {}) => this.request({
      path: `/v1/jobs/${jobId}`,
      method: "DELETE",
      format: "json",
      ...params
    }),
    /**
     * @description cancel job
     *
     * @tags models
     * @name TamsApiV1ServiceGetModel
     * @summary v1/models/{model_id}
     * @request GET:/v1/models/{modelId}
     */
    tamsApiV1ServiceGetModel: (modelId, params = {}) => this.request({
      path: `/v1/models/${modelId}`,
      method: "GET",
      format: "json",
      ...params
    }),
    /**
     * @description create resource image
     *
     * @tags resource
     * @name TamsApiV1ServiceCreateResourceImage
     * @summary v1/resource/image
     * @request POST:/v1/resource/image
     */
    tamsApiV1ServiceCreateResourceImage: (body, params = {}) => this.request({
      path: `/v1/resource/image`,
      method: "POST",
      body,
      type: "application/json" /* Json */,
      format: "json",
      ...params
    }),
    /**
     * @description create resource image sts
     *
     * @tags resource
     * @name TamsApiV1ServiceCreateResourceImageSts
     * @summary v1/resource/image/sts
     * @request POST:/v1/resource/image/sts
     */
    tamsApiV1ServiceCreateResourceImageSts: (body, params = {}) => this.request({
      path: `/v1/resource/image/sts`,
      method: "POST",
      body,
      type: "application/json" /* Json */,
      format: "json",
      ...params
    })
  };
};

// src/index.ts
import crypto from "crypto";
import { fetch as fetch2, Headers, Blob as Blob2 } from "node-fetch-native";
var Sha256RsaAuthenticateStrategy = class {
  constructor(privateKey) {
    this.privateKey = privateKey;
  }
  getHeaders({ resource, options, appId }) {
    const method = options?.method ?? "GET";
    const url = new URL(resource.toString());
    const path = url.pathname + url.search;
    const timestamp = Math.floor(Date.now() / 1e3);
    const nonce = Math.random().toString(16).slice(2);
    const body = options?.body ? options.body.toString() : "";
    const content = `${method}
${path}
${timestamp}
${nonce}
${body}`;
    const sign = crypto.createSign("RSA-SHA256");
    sign.update(content);
    const signature = sign.sign(this.privateKey, "base64");
    return new Headers({
      authorization: `TAMS-SHA256-RSA app_id=${appId},nonce_str=${nonce},timestamp=${timestamp},signature=${signature}`
    });
  }
};
var TamsSDK = class {
  api;
  appId;
  authenticateStrategy;
  host;
  constructor(options) {
    this.appId = options.appId;
    this.authenticateStrategy = options.authenticateStrategy;
    this.host = options.host ?? "tams-api.tensor.art";
    this.api = new Api({
      baseUrl: `https://${this.host}`,
      customFetch: async (...fetchParams) => {
        const headers = this.authenticateStrategy.getHeaders({
          resource: fetchParams[0],
          options: fetchParams[1],
          appId: this.appId
        });
        fetchParams[1] = fetchParams[1] || {};
        const init = fetchParams[1];
        const nextHeaders = new Headers(init.headers || {});
        headers.forEach((v, k) => {
          nextHeaders.append(k, v);
        });
        fetchParams[1].headers = nextHeaders;
        const resp = await fetch2.apply(globalThis, fetchParams);
        return resp;
      }
    });
  }
  get v1() {
    return this.api.v1;
  }
  async uploadFile({
    file
  }) {
    const resp = await this.api.v1.tamsApiV1ServiceCreateResourceImage({
      expireSec: `${60 * 60}`,
      term: 1
    });
    console.log(`\u8D44\u6E90\u521B\u5EFA`, resp.data);
    if (Buffer.isBuffer(file)) {
      file = new Blob2([file]);
    }
    const uploadResp = await fetch2(resp.data.putUrl, {
      headers: resp.data.headers,
      body: file,
      method: "PUT"
    });
    console.log(`\u4E0A\u4F20\u8D44\u6E90\u5B8C\u6210`);
    if (uploadResp.ok) {
      return {
        resourceId: resp.data.resourceId
      };
    }
    throw new Error(`upload file failed: ${uploadResp.statusText}`);
  }
};
export {
  Sha256RsaAuthenticateStrategy,
  TamsSDK,
  tams_exports as t
};
//# sourceMappingURL=index.mjs.map