interface CreateJobRequestStage {
    /**
     * stage type
     * stage type
     */
    type: TamsApiStageTypeT;
    inputInitialize?: TamsApiInputInitializeInput;
    diffusion?: TamsApiDiffusionInput;
    imageToUpscaler?: TamsApiImageToUpscalerInput;
    imageToAdetailer?: TamsApiImageToAdetailerInput;
    imageToInpaint?: TamsApiImageToInpaintInput;
}
/** @default "DEFAULT" */
declare enum ImageToInpaintInputInpaintFillT {
    DEFAULT = "DEFAULT",
    FILL = "FILL",
    ORIGINAL = "ORIGINAL",
    LATENT_NOISE = "LATENT_NOISE",
    LATENT_NOTHING = "LATENT_NOTHING"
}
/** @default "DEFAULT" */
declare enum ImageToInpaintInputResizeModeT {
    DEFAULT = "DEFAULT",
    JUST_RESIZE = "JUST_RESIZE",
    CROP_AND_RESIZE = "CROP_AND_RESIZE",
    RESIZE_AND_FILL = "RESIZE_AND_FILL",
    JUST_RESIZE_LATENT_UPSCALE = "JUST_RESIZE_LATENT_UPSCALE"
}
interface LoraItem {
    loraModel?: string;
    /** @format float */
    weight?: number;
    /**
     * lora block weight, value such as \<weight\>:lbw=\<layer weight\>
     * example: "1:lbw=1,1,1,1,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0"
     */
    blockWeight?: string;
}
/** @default "DEFAULT" */
declare enum ProjectModelTypeT {
    DEFAULT = "DEFAULT",
    CHECKPOINT = "CHECKPOINT",
    TEXTUAL_INVERSION = "TEXTUAL_INVERSION",
    HYPERNETWORK = "HYPERNETWORK",
    AESTHETIC_GRADIENT = "AESTHETIC_GRADIENT",
    LORA = "LORA",
    LOCON = "LOCON",
    CONTROLNET = "CONTROLNET",
    POSES = "POSES",
    WILDCARDS = "WILDCARDS",
    OTHER = "OTHER",
    LYCORIS = "LYCORIS"
}
interface GooglerpcStatus {
    /** @format int32 */
    code?: number;
    message?: string;
    details?: ProtobufAny[];
}
interface ProtobufAny {
    '@type'?: string;
    [key: string]: any;
}
/**
 * `NullValue` is a singleton enumeration to represent the null value for the
 * `Value` type union.
 *
 *  The JSON representation for `NullValue` is JSON `null`.
 *
 *  - NULL_VALUE: Null value.
 * @default "NULL_VALUE"
 */
declare enum ProtobufNullValue {
    NULL_VALUE = "NULL_VALUE"
}
interface TamsApiAdetailerArg {
    /** @default "face_yolov8n.pt" */
    adModel?: string;
    adPrompt?: TamsApiPrompt[];
    adNegativePrompt?: TamsApiPrompt[];
    /**
     * @format float
     * @default "face_yolov8n.pt"
     */
    adConfidence?: number;
    /**
     * @format int32
     * @default "4"
     */
    adDilateErode?: number;
    /** @default "None" */
    adMaskMergeInvert?: string;
    /**
     * @format float
     * @default "0.4"
     */
    adDenoisingStrength?: number;
    /** @default "true" */
    adInpaintOnlyMasked?: boolean;
    /**
     * @format float
     * @default "32"
     */
    adInpaintOnlyMaskedPadding?: number;
    /** @default "false" */
    adUseInpaintWidthHeight?: boolean;
    /**
     * @format int32
     * @default "512"
     */
    adInpaintWidth?: number;
    /**
     * @format int32
     * @default "512"
     */
    adInpaintHeight?: number;
    /** @default "false" */
    adUseSteps?: boolean;
    /**
     * @format int32
     * @default "20"
     */
    adSteps?: number;
    /** @default "false" */
    adUseCfgScale?: boolean;
    /**
     * @format float
     * @default "7"
     */
    adCfgScale?: number;
    lora?: TamsApiLora;
}
interface TamsApiCancelJobResponse {
    /** @format uint64 */
    jobId?: string;
}
interface TamsApiControlnet {
    args?: TamsApiControlnetArgs[];
}
interface TamsApiControlnetArgs {
    inputImageResourceId?: string;
    mask?: string;
    /**
     * The model to use for the controlnet preprocessor
     * support
     * @example {}
     */
    preprocessor: string;
    /**
     * The model to use for the controlnet
     * support list: ["control_v11p_sd15_openpose","control_v11p_sd15_canny","control_v11f1p_sd15_depth","control_v11p_sd15_lineart","control_v11p_sd15s2_lineart_anime","control_v11p_sd15_mlsd","control_v11p_sd15_normalbae","control_v11p_sd15_scribble","control_v11p_sd15_softedge","control_v11p_sd15_seg","control_v11e_sd15_shuffle","t2iadapter_color_sd14v1","control_v11f1e_sd15_tile","control_v11e_sd15_ip2p","control_v1p_sd15_qrcode_monster","control_v1p_sd15_brightness", "None"]
     * @example {}
     */
    model: string;
    /** @format float */
    weight?: number;
    resizeMode?: string;
    /** @format float */
    guidance?: number;
    /** @format float */
    guidanceStart?: number;
    /** @format float */
    guidanceEnd?: number;
    controlMode?: string;
    pixelPerfect?: boolean;
    preprocessorParams?: object;
}
interface TamsApiCreateJobRequest {
    /** ensure request idempotence, should be unique */
    requestId: string;
    /** stages to be executed */
    stages: CreateJobRequestStage[];
    notifyUrl?: string;
}
interface TamsApiCreateJobResponse {
    job?: TamsApiJobInfoForClient;
}
interface TamsApiCreateResourceImageRequest {
    /** @format int64 */
    expireSec?: string;
    /**
     * term of resource, 1-short(keep 7days) 2-long(keep forever)
     * @format int32
     */
    term?: number;
}
interface TamsApiCreateResourceImageResponse {
    resourceId?: string;
    putUrl?: string;
    headers?: object;
}
interface TamsApiCreateResourceImageSTSRequest {
    /** @format int64 */
    expireSec?: string;
    /**
     * term of resource, 1-short(keep 7days) 2-long(keep forever)
     * @format int32
     */
    term?: number;
}
interface TamsApiCreateResourceImageSTSResponse {
    resourceId?: string;
    accessId?: string;
    signature?: string;
    host?: string;
    expire?: string;
    callback?: string;
    filePath?: string;
    policy?: string;
    securityToken?: string;
}
interface TamsApiDiffusionInput {
    /**
     * Height of the image in pixels. Must be in increments of 64 and pass the following validation:
     * - For 512 engines: 262,144 ≤ height * width ≤ 1,048,576, Maximum 1024
     * - For 768 engines: 589,824 ≤ height * width ≤ 1,048,576, Maximum 1024
     * - For SDXL v1.0: 262,144 ≤ height * width ≤ 2,073,600, Maximum 1536
     * @format int64
     * @min 512
     * @max 1536
     * @default "512"
     */
    width: number;
    /**
     * Height of the image in pixels. Must be in increments of 64 and pass the following validation:
     * - For 512 engines: 262,144 ≤ height * width ≤ 1,048,576, Maximum 1024
     * - For 768 engines: 589,824 ≤ height * width ≤ 1,048,576, Maximum 1024
     * - For SDXL v1.0: 262,144 ≤ height * width ≤ 2,073,600, Maximum 1536
     * @format int64
     * @min 512
     * @max 1536
     * @default "512"
     */
    height: number;
    /**
     * An array of text prompts to use for generation. Given a text prompt with the text A lighthouse on a cliff and a weight of 0.5, it would be represented as:
     * @example {}
     */
    prompts: TamsApiPrompt[];
    /**
     * An array of text negative prompts to use for generation. Given a text prompt with the text A lighthouse on a cliff and a weight of 0.5, it would be represented as:
     * @example {}
     */
    negativePrompts: TamsApiPrompt[];
    /**
     * The model to use for the diffusion
     * @example {}
     */
    sdModel?: string;
    /**
     * The vae to use for the diffusion
     * support list: ["Automatic","None","vae-ft-mse-840000-ema-pruned.ckpt","kl-f8-anime.ckpt","kl-f8-anime2.ckpt","YOZORA.vae.pt","orangemix.vae.pt","blessed2.vae.pt,animevae.pt","ClearVAE.safetensors","pastel-waifu-diffusion.vae.pt"]
     * @example {}
     */
    sdVae?: string;
    /**
     * Which sampler to use for the diffusion process. If this value is omitted we'll automatically select an appropriate sampler for you.
     * support list: ["Euler a","Euler","LMS","Heun","DPM2","DPM2 a","DPM++ 2S a","DPM++ 2M","DPM++ SDE","DPM++ 2M SDE","DPM fast","LMS Karras","DPM2 Karras","DPM2 a Karras","DPM++ 2S a Karras","DPM++ 2M Karras","DPM++ SDE Karras","DPM++ 2M SDE Karras"]
     */
    sampler?: string;
    /**
     * Number of diffusion steps to run.
     * @format int32
     * @min 10
     * @max 50
     * @default "0"
     */
    steps?: number;
    /**
     * How strictly the diffusion process adheres to the prompt text (higher values keep your image closer to your prompt)
     * @format float
     * @max 35
     * @default "7"
     */
    cfgScale?: number;
    /** @format int32 */
    clipSkip?: number;
    /** @format float */
    denoisingStrength?: number;
    /** @format int32 */
    etaNoiseSeedDelta?: number;
    controlnet?: TamsApiControlnet;
    lora?: TamsApiLora;
}
interface TamsApiFailedInfo {
    reason?: string;
    /** already finished stages info */
    stages?: TamsApiStageInfo[];
}
interface TamsApiGetJobResponse {
    job?: TamsApiJobInfoForClient;
}
interface TamsApiGetModelResponse {
    model?: TamsApiModel;
}
interface TamsApiImageToAdetailerInput {
    args?: TamsApiAdetailerArg[];
    diffusion?: TamsApiDiffusionInput;
}
interface TamsApiImageToInpaintInput {
    /** JUST_RESIZE */
    resizeMode?: ImageToInpaintInputResizeModeT;
    maskImageResourceId?: string;
    /**
     * 4
     * @format int64
     */
    maskBlur?: number;
    /** ORIGINAL */
    inpaintingFill?: ImageToInpaintInputInpaintFillT;
    /** true */
    inpaintFullRes?: boolean;
    /**
     * 32
     * @format int64
     */
    inpaintFullResPadding?: number;
    /**
     * 0
     * @format int64
     */
    inpaintMaskInvert?: number;
    diffusion?: TamsApiDiffusionInput;
}
interface TamsApiImageToUpscalerInput {
    /**
     * The model to use for the upscaling
     * - 262,144 ≤ hr_resize_x * hr_resize_y ≤ 2,073,600
     * support list: ["Latent","Latent (antialiased)","Latent (bicubic)","Latent (bicubic antialiased)","Latent (nearest)","Latent (nearest-exact)","None","Lanczos","Nearest","4x-UltraSharp","4x_foolhardy_Remacri","ESRGAN_4x","R-ESRGAN 4x+","R-ESRGAN 4x+ Anime6B","4x_NMKD-Siax_200k","4x-AnimeSharp","4x_NMKD-Superscale-SP_178000_G","SwinIR_4x","8x_NMKD-Superscale_150000_G",]
     * @example {}
     */
    hrUpscaler: string;
    /**
     * hr_scale or hr_resize_x must be specified. If hr_scale is specified, hr_resize_x will be ignored.
     * Height of the image upscaler in pixels. Must be in increments of 64 and pass the following validation:
     * - 262,144 ≤ hr_resize_x * hr_resize_y ≤ 2,073,600
     * @format int64
     * @min 128
     */
    hrResizeX?: number;
    /**
     * hr_scale or hr_resize_y must be specified. If hr_scale is specified, hr_resize_y will be ignored.
     * Height of the image upscaler in pixels. Must be in increments of 64 and pass the following validation:
     * - 262,144 ≤ hr_resize_x * hr_resize_y ≤ 2,073,600
     * @format int64
     * @min 128
     */
    hrResizeY?: number;
    /**
     * The size to use for the upscaling
     * - 262,144 ≤ hr_resize_x * hr_resize_y ≤ 2,073,600
     * @format int32
     * @example {}
     */
    hrScale?: number;
    /**
     * Number of diffusion steps to run.
     * @format int32
     * @example {}
     */
    hrSecondPassSteps: number;
    /**
     * denoising_strength
     * @format float
     * @example {}
     */
    denoisingStrength: number;
    /**
     * if has diffusion stage, this diffusion will be ignored, else need to be specified
     * @example {}
     */
    diffusion?: TamsApiDiffusionInput;
}
interface TamsApiInputInitializeInput {
    /**
     * Random noise seed (omit this option or use 0 for a random seed).
     * @format int64
     * @max 4294967295
     * @default "0"
     */
    seed?: string;
    /** Image used to initialize the diffusion process, in lieu of random noise. */
    imageResourceId?: string;
    /**
     * Number of images to generate
     * @format int32
     * @min 1
     * @max 4
     * @default "1"
     */
    count?: number;
}
interface TamsApiJobInfoForClient {
    /**
     * job id
     * @format uint64
     */
    id?: string;
    /** job status */
    status?: TamsApiJobStatusT;
    /** waiting info, when status is waiting will return this */
    waitingInfo?: TamsApiWaitingInfo;
    /** failed info, when status is failed will return this */
    failedInfo?: TamsApiFailedInfo;
    /** running info, when status is running will return this */
    runningInfo?: TamsApiRunningInfo;
    /** success info, when status is success will return this */
    successInfo?: TamsApiSuccessInfo;
}
/** @default "DEFAULT" */
declare enum TamsApiJobStatusT {
    DEFAULT = "DEFAULT",
    CREATED = "CREATED",
    PENDING = "PENDING",
    RUNNING = "RUNNING",
    CANCELED = "CANCELED",
    SUCCESS = "SUCCESS",
    FAILED = "FAILED",
    WAITING = "WAITING"
}
interface TamsApiLora {
    items?: LoraItem[];
}
interface TamsApiModel {
    /** @format uint64 */
    id?: string;
    name?: string;
    description?: string;
    baseModel?: string;
    modelType?: ProjectModelTypeT;
    showcaseImageUrls?: string[];
    projectName?: string;
}
interface TamsApiProcessingImage {
    resourceImage?: TamsApiResourceForClient;
    /** @format int32 */
    progress?: number;
}
interface TamsApiPrompt {
    text?: string;
    /** @format float */
    weight?: number;
}
interface TamsApiResourceForClient {
    id?: string;
    url?: string;
    /** @format int64 */
    expiredIn?: string;
}
interface TamsApiRunningInfo {
    /** already finished stages or running stages info */
    stages?: TamsApiStageInfo[];
}
interface TamsApiStageInfo {
    /**
     * stage in job index
     * @format int64
     */
    stageIndex?: string;
    processingImages?: TamsApiProcessingImage[];
}
/** @default "DEFAULT" */
declare enum TamsApiStageTypeT {
    DEFAULT = "DEFAULT",
    INPUT_INITIALIZE = "INPUT_INITIALIZE",
    DIFFUSION = "DIFFUSION",
    IMAGE_TO_UPSCALER = "IMAGE_TO_UPSCALER",
    IMAGE_TO_ADETAILER = "IMAGE_TO_ADETAILER",
    IMAGE_TO_INPAINT = "IMAGE_TO_INPAINT"
}
interface TamsApiSuccessInfo {
    /** final output images */
    images?: TamsApiResourceForClient[];
    /** all stages info */
    stages?: TamsApiStageInfo[];
}
interface TamsApiWaitingInfo {
    /** @format int64 */
    queueRank?: string;
}
type QueryParamsType = Record<string | number, any>;
type ResponseFormat = keyof Omit<Body, 'body' | 'bodyUsed'>;
interface FullRequestParams extends Omit<RequestInit, 'body'> {
    /** set parameter to `true` for call `securityWorker` for this request */
    secure?: boolean;
    /** request path */
    path: string;
    /** content type of request body */
    type?: ContentType;
    /** query params */
    query?: QueryParamsType;
    /** format of response (i.e. response.json() -> format: "json") */
    format?: ResponseFormat;
    /** request body */
    body?: unknown;
    /** base url */
    baseUrl?: string;
    /** request cancellation token */
    cancelToken?: CancelToken;
}
type RequestParams = Omit<FullRequestParams, 'body' | 'method' | 'query' | 'path'>;
interface ApiConfig<SecurityDataType = unknown> {
    baseUrl?: string;
    baseApiParams?: Omit<RequestParams, 'baseUrl' | 'cancelToken' | 'signal'>;
    securityWorker?: (securityData: SecurityDataType | null) => Promise<RequestParams | void> | RequestParams | void;
    customFetch?: typeof fetch;
}
interface HttpResponse<D extends unknown, E extends unknown = unknown> {
    data: D;
    error: E;
    headers: Headers;
    ok: boolean;
}
type CancelToken = Symbol | string | number;
declare enum ContentType {
    Json = "application/json",
    FormData = "multipart/form-data",
    UrlEncoded = "application/x-www-form-urlencoded",
    Text = "text/plain"
}
declare class HttpClient<SecurityDataType = unknown> {
    baseUrl: string;
    private securityData;
    private securityWorker?;
    private abortControllers;
    private customFetch;
    private baseApiParams;
    constructor(apiConfig?: ApiConfig<SecurityDataType>);
    setSecurityData: (data: SecurityDataType | null) => void;
    protected encodeQueryParam(key: string, value: any): string;
    protected addQueryParam(query: QueryParamsType, key: string): string;
    protected addArrayQueryParam(query: QueryParamsType, key: string): any;
    protected toQueryString(rawQuery?: QueryParamsType): string;
    protected addQueryParams(rawQuery?: QueryParamsType): string;
    private contentFormatters;
    protected mergeRequestParams(params1: RequestParams, params2?: RequestParams): RequestParams;
    protected createAbortSignal: (cancelToken: CancelToken) => AbortSignal | undefined;
    abortRequest: (cancelToken: CancelToken) => void;
    request: <T = any, E = any>({ body, secure, path, type, query, format, baseUrl, cancelToken, ...params }: FullRequestParams) => Promise<HttpResponse<T, E>>;
}
/**
 * @title TAMS API
 * @version v1
 * @baseUrl https://tams.tensor.art
 */
declare class Api<SecurityDataType extends unknown> extends HttpClient<SecurityDataType> {
    v1: {
        /**
         * @description create diffusion job
         *
         * @tags jobs
         * @name TamsApiV1ServiceCreateJob
         * @summary v1/jobs
         * @request POST:/v1/jobs
         */
        tamsApiV1ServiceCreateJob: (body: TamsApiCreateJobRequest, params?: RequestParams) => Promise<HttpResponse<TamsApiCreateJobResponse, GooglerpcStatus>>;
        /**
         * @description get job
         *
         * @tags jobs
         * @name TamsApiV1ServiceGetJob
         * @summary v1/jobs
         * @request GET:/v1/jobs/{jobId}
         */
        tamsApiV1ServiceGetJob: (jobId: string, params?: RequestParams) => Promise<HttpResponse<TamsApiGetJobResponse, GooglerpcStatus>>;
        /**
         * @description cancel job
         *
         * @tags jobs
         * @name TamsApiV1ServiceCancelJob
         * @summary v1/jobs
         * @request DELETE:/v1/jobs/{jobId}
         */
        tamsApiV1ServiceCancelJob: (jobId: string, params?: RequestParams) => Promise<HttpResponse<TamsApiCancelJobResponse, GooglerpcStatus>>;
        /**
         * @description cancel job
         *
         * @tags models
         * @name TamsApiV1ServiceGetModel
         * @summary v1/models/{model_id}
         * @request GET:/v1/models/{modelId}
         */
        tamsApiV1ServiceGetModel: (modelId: string, params?: RequestParams) => Promise<HttpResponse<TamsApiGetModelResponse, GooglerpcStatus>>;
        /**
         * @description create resource image
         *
         * @tags resource
         * @name TamsApiV1ServiceCreateResourceImage
         * @summary v1/resource/image
         * @request POST:/v1/resource/image
         */
        tamsApiV1ServiceCreateResourceImage: (body: TamsApiCreateResourceImageRequest, params?: RequestParams) => Promise<HttpResponse<TamsApiCreateResourceImageResponse, GooglerpcStatus>>;
        /**
         * @description create resource image sts
         *
         * @tags resource
         * @name TamsApiV1ServiceCreateResourceImageSts
         * @summary v1/resource/image/sts
         * @request POST:/v1/resource/image/sts
         */
        tamsApiV1ServiceCreateResourceImageSts: (body: TamsApiCreateResourceImageSTSRequest, params?: RequestParams) => Promise<HttpResponse<TamsApiCreateResourceImageSTSResponse, GooglerpcStatus>>;
    };
}

type tams_Api<SecurityDataType extends unknown> = Api<SecurityDataType>;
declare const tams_Api: typeof Api;
type tams_ApiConfig<SecurityDataType = unknown> = ApiConfig<SecurityDataType>;
type tams_ContentType = ContentType;
declare const tams_ContentType: typeof ContentType;
type tams_CreateJobRequestStage = CreateJobRequestStage;
type tams_FullRequestParams = FullRequestParams;
type tams_GooglerpcStatus = GooglerpcStatus;
type tams_HttpClient<SecurityDataType = unknown> = HttpClient<SecurityDataType>;
declare const tams_HttpClient: typeof HttpClient;
type tams_HttpResponse<D extends unknown, E extends unknown = unknown> = HttpResponse<D, E>;
type tams_ImageToInpaintInputInpaintFillT = ImageToInpaintInputInpaintFillT;
declare const tams_ImageToInpaintInputInpaintFillT: typeof ImageToInpaintInputInpaintFillT;
type tams_ImageToInpaintInputResizeModeT = ImageToInpaintInputResizeModeT;
declare const tams_ImageToInpaintInputResizeModeT: typeof ImageToInpaintInputResizeModeT;
type tams_LoraItem = LoraItem;
type tams_ProjectModelTypeT = ProjectModelTypeT;
declare const tams_ProjectModelTypeT: typeof ProjectModelTypeT;
type tams_ProtobufAny = ProtobufAny;
type tams_ProtobufNullValue = ProtobufNullValue;
declare const tams_ProtobufNullValue: typeof ProtobufNullValue;
type tams_QueryParamsType = QueryParamsType;
type tams_RequestParams = RequestParams;
type tams_ResponseFormat = ResponseFormat;
type tams_TamsApiAdetailerArg = TamsApiAdetailerArg;
type tams_TamsApiCancelJobResponse = TamsApiCancelJobResponse;
type tams_TamsApiControlnet = TamsApiControlnet;
type tams_TamsApiControlnetArgs = TamsApiControlnetArgs;
type tams_TamsApiCreateJobRequest = TamsApiCreateJobRequest;
type tams_TamsApiCreateJobResponse = TamsApiCreateJobResponse;
type tams_TamsApiCreateResourceImageRequest = TamsApiCreateResourceImageRequest;
type tams_TamsApiCreateResourceImageResponse = TamsApiCreateResourceImageResponse;
type tams_TamsApiCreateResourceImageSTSRequest = TamsApiCreateResourceImageSTSRequest;
type tams_TamsApiCreateResourceImageSTSResponse = TamsApiCreateResourceImageSTSResponse;
type tams_TamsApiDiffusionInput = TamsApiDiffusionInput;
type tams_TamsApiFailedInfo = TamsApiFailedInfo;
type tams_TamsApiGetJobResponse = TamsApiGetJobResponse;
type tams_TamsApiGetModelResponse = TamsApiGetModelResponse;
type tams_TamsApiImageToAdetailerInput = TamsApiImageToAdetailerInput;
type tams_TamsApiImageToInpaintInput = TamsApiImageToInpaintInput;
type tams_TamsApiImageToUpscalerInput = TamsApiImageToUpscalerInput;
type tams_TamsApiInputInitializeInput = TamsApiInputInitializeInput;
type tams_TamsApiJobInfoForClient = TamsApiJobInfoForClient;
type tams_TamsApiJobStatusT = TamsApiJobStatusT;
declare const tams_TamsApiJobStatusT: typeof TamsApiJobStatusT;
type tams_TamsApiLora = TamsApiLora;
type tams_TamsApiModel = TamsApiModel;
type tams_TamsApiProcessingImage = TamsApiProcessingImage;
type tams_TamsApiPrompt = TamsApiPrompt;
type tams_TamsApiResourceForClient = TamsApiResourceForClient;
type tams_TamsApiRunningInfo = TamsApiRunningInfo;
type tams_TamsApiStageInfo = TamsApiStageInfo;
type tams_TamsApiStageTypeT = TamsApiStageTypeT;
declare const tams_TamsApiStageTypeT: typeof TamsApiStageTypeT;
type tams_TamsApiSuccessInfo = TamsApiSuccessInfo;
type tams_TamsApiWaitingInfo = TamsApiWaitingInfo;
declare namespace tams {
  export {
    tams_Api as Api,
    tams_ApiConfig as ApiConfig,
    tams_ContentType as ContentType,
    tams_CreateJobRequestStage as CreateJobRequestStage,
    tams_FullRequestParams as FullRequestParams,
    tams_GooglerpcStatus as GooglerpcStatus,
    tams_HttpClient as HttpClient,
    tams_HttpResponse as HttpResponse,
    tams_ImageToInpaintInputInpaintFillT as ImageToInpaintInputInpaintFillT,
    tams_ImageToInpaintInputResizeModeT as ImageToInpaintInputResizeModeT,
    tams_LoraItem as LoraItem,
    tams_ProjectModelTypeT as ProjectModelTypeT,
    tams_ProtobufAny as ProtobufAny,
    tams_ProtobufNullValue as ProtobufNullValue,
    tams_QueryParamsType as QueryParamsType,
    tams_RequestParams as RequestParams,
    tams_ResponseFormat as ResponseFormat,
    tams_TamsApiAdetailerArg as TamsApiAdetailerArg,
    tams_TamsApiCancelJobResponse as TamsApiCancelJobResponse,
    tams_TamsApiControlnet as TamsApiControlnet,
    tams_TamsApiControlnetArgs as TamsApiControlnetArgs,
    tams_TamsApiCreateJobRequest as TamsApiCreateJobRequest,
    tams_TamsApiCreateJobResponse as TamsApiCreateJobResponse,
    tams_TamsApiCreateResourceImageRequest as TamsApiCreateResourceImageRequest,
    tams_TamsApiCreateResourceImageResponse as TamsApiCreateResourceImageResponse,
    tams_TamsApiCreateResourceImageSTSRequest as TamsApiCreateResourceImageSTSRequest,
    tams_TamsApiCreateResourceImageSTSResponse as TamsApiCreateResourceImageSTSResponse,
    tams_TamsApiDiffusionInput as TamsApiDiffusionInput,
    tams_TamsApiFailedInfo as TamsApiFailedInfo,
    tams_TamsApiGetJobResponse as TamsApiGetJobResponse,
    tams_TamsApiGetModelResponse as TamsApiGetModelResponse,
    tams_TamsApiImageToAdetailerInput as TamsApiImageToAdetailerInput,
    tams_TamsApiImageToInpaintInput as TamsApiImageToInpaintInput,
    tams_TamsApiImageToUpscalerInput as TamsApiImageToUpscalerInput,
    tams_TamsApiInputInitializeInput as TamsApiInputInitializeInput,
    tams_TamsApiJobInfoForClient as TamsApiJobInfoForClient,
    tams_TamsApiJobStatusT as TamsApiJobStatusT,
    tams_TamsApiLora as TamsApiLora,
    tams_TamsApiModel as TamsApiModel,
    tams_TamsApiProcessingImage as TamsApiProcessingImage,
    tams_TamsApiPrompt as TamsApiPrompt,
    tams_TamsApiResourceForClient as TamsApiResourceForClient,
    tams_TamsApiRunningInfo as TamsApiRunningInfo,
    tams_TamsApiStageInfo as TamsApiStageInfo,
    tams_TamsApiStageTypeT as TamsApiStageTypeT,
    tams_TamsApiSuccessInfo as TamsApiSuccessInfo,
    tams_TamsApiWaitingInfo as TamsApiWaitingInfo,
  };
}

type GetHeadersParams = {
    resource: URL | RequestInfo;
    options?: RequestInit;
    appId: string;
};
interface AuthenticateStrategy {
    getHeaders(params: GetHeadersParams): Headers;
}
declare class Sha256RsaAuthenticateStrategy implements AuthenticateStrategy {
    private privateKey;
    constructor(privateKey: string);
    getHeaders({ resource, options, appId }: GetHeadersParams): Headers;
}
type TamsSDKOptions = {
    appId: string;
    authenticateStrategy: AuthenticateStrategy;
    host?: string;
};
declare class TamsSDK {
    private api;
    private appId;
    private authenticateStrategy;
    private host;
    constructor(options: TamsSDKOptions);
    get v1(): {
        tamsApiV1ServiceCreateJob: (body: TamsApiCreateJobRequest, params?: RequestParams) => Promise<HttpResponse<TamsApiCreateJobResponse, GooglerpcStatus>>;
        tamsApiV1ServiceGetJob: (jobId: string, params?: RequestParams) => Promise<HttpResponse<TamsApiGetJobResponse, GooglerpcStatus>>;
        tamsApiV1ServiceCancelJob: (jobId: string, params?: RequestParams) => Promise<HttpResponse<TamsApiCancelJobResponse, GooglerpcStatus>>;
        tamsApiV1ServiceGetModel: (modelId: string, params?: RequestParams) => Promise<HttpResponse<TamsApiGetModelResponse, GooglerpcStatus>>;
        tamsApiV1ServiceCreateResourceImage: (body: TamsApiCreateResourceImageRequest, params?: RequestParams) => Promise<HttpResponse<TamsApiCreateResourceImageResponse, GooglerpcStatus>>;
        tamsApiV1ServiceCreateResourceImageSts: (body: TamsApiCreateResourceImageSTSRequest, params?: RequestParams) => Promise<HttpResponse<TamsApiCreateResourceImageSTSResponse, GooglerpcStatus>>;
    };
    uploadFile({ file, }: {
        file: Buffer | ReadableStream | File | Blob;
    }): Promise<{
        resourceId: string;
    }>;
}

export { Sha256RsaAuthenticateStrategy, TamsSDK, tams as t };
